use bincode::Options;
use std::net::Ipv4Addr;
use core::convert::TryInto;
use log::{debug};
use serde_repr::{Serialize_repr, Deserialize_repr};
use std::fmt;

use crate::netflow::NetflowMsg;

pub const VERSION: u16 = 10;
pub const HEADER_SIZE: usize = std::mem::size_of::<Header>();

/// MSG HEADER ////

/*
from https://tools.ietf.org/html/rfc7011

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Version Number          |            Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Export Time                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Sequence Number                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Observation Domain ID                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

#[derive(Deserialize, Debug)]
pub struct Header {
    pub version: u16,       // Version of IPFIX to which this Message conforms
    pub length: u16,        // Total length of the IPFIX Message, measured in octets, including Message Header and Set(s).
    pub export_time: u32,   // Time at which the IPFIX Message Header leaves the Exporter expressed in seconds since the UNIX epoch
    pub seq_number: u32,    // Incremental sequence counter modulo 2^32 of all IPFIX Data Record sent in the current stream from the current Observation Domain by the Exporting Process.
    pub domain_id: u32,     // Identifier used to uniquely identify to the Collecting Process the Observation Domain that metered the Flows
}

impl Header {
    pub fn read(buf: &[u8]) -> Self {
         bincode::DefaultOptions::new()
            .with_fixint_encoding()
            .allow_trailing_bytes()
            .with_big_endian()
            .deserialize_from::<_,Self>(buf).unwrap()
    }
}

/// SET HEADER ///

/*
from https://tools.ietf.org/html/rfc7011

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Set ID               |          Length               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

pub const SET_HEADER_SIZE: usize = std::mem::size_of::<SetHeader>();
pub const TEMPATE_SET_ID: u16 = 2;
pub const OPTION_TEMPATE_SET_ID: u16 = 3;
pub const DATA_SET_ID_MIN: u16 = 256;

#[derive(Deserialize, Debug)]
pub struct SetHeader {
    pub set_id: u16,  // Identifies the Set.
    pub length: u16,  // Total length of the Set, in octets, including the Set Header, all records, and the optional padding
}

impl SetHeader {
    pub fn read(buf: &[u8]) -> Self {
         bincode::DefaultOptions::new()
            .with_fixint_encoding()
            .allow_trailing_bytes()
            .with_big_endian()
            .deserialize_from::<_,Self>(buf).unwrap()
    }
}

/// TEMPLATE HEADER ///

/*
from https://tools.ietf.org/html/rfc7011

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Template ID (> 255)      |         Field Count           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

pub const TEMPLATE_HEADER_SIZE: usize = 4;

#[derive(Deserialize, Debug)]
pub struct TemplateHeader {
    pub id: u16,            // Each Template Record is given a unique Template ID in the range 256 to 65535
    pub field_count: u16,   // Number of fields in this Template Record.

}

impl TemplateHeader {
    pub fn read(buf: &[u8]) -> Self {
         bincode::DefaultOptions::new()
            .with_fixint_encoding()
            .allow_trailing_bytes()
            .with_big_endian()
            .deserialize_from::<_,Self>(buf).unwrap()
    }
}

impl fmt::Display for TemplateHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "id: {}, field_count: {}", self.id, self.field_count)
    }
}

/// TEMPLATE RECORD FIELD ///

/*
from https://tools.ietf.org/html/rfc7011

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Field id             |         Field Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/

pub const TEMPLATE_FIELD_SIZE: usize = 4;

#[derive(Deserialize, Debug)]
pub struct TemplateField {
    pub id: FieldType,
    pub length: u16,
}

impl TemplateField {
    pub fn read(buf: &[u8]) -> Self {
         bincode::DefaultOptions::new()
            .with_fixint_encoding()
            .allow_trailing_bytes()
            .with_big_endian()
            .deserialize_from::<_,Self>(buf).unwrap()
    }
}

impl fmt::Display for TemplateField {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "id: {:?}, len: {}", self.id, self.length)
    }
}

/// DATA SET ///
//TODO plutot qu'utiliser une structure avec des champs fixe, il faudrait utiliser une Hashmap<FieldType,Value> et parser tout les fields du template
// et implémenter un getter pour retourner les valeurs en foection des clés
#[derive(Deserialize, Debug, Default)]
pub struct DataSet {
    pub src_addr: u32,
    pub dst_addr: u32,
    pub input_int: u16,
    pub output_int: u16,
    pub octets: u32,
    pub packets: u32,
    pub start_time: u64,
	pub end_time: u64,
    pub src_port: u16,
    pub dst_port: u16, 
    pub protocol: u8,
	pub end_reason: u8,
	pub tos: u8
}

impl DataSet {
    pub fn read(buf: &[u8], template: &Vec<TemplateField>) -> Self {
		let mut set = DataSet{..Default::default()};
		let mut offset = 0;

		for field in template {
			match field.id {
				FieldType::SOURCEIPV4ADDRESS => {
					set.src_addr = u32::from_be_bytes(buf[offset..offset + 4].try_into().unwrap());
				},
				FieldType::DESTINATIONIPV4ADDRESS => {
					set.dst_addr = u32::from_be_bytes(buf[offset..offset + 4].try_into().unwrap());
				},
				FieldType::OCTETDELTACOUNT => {
					set.octets = u32::from_be_bytes(buf[offset..offset + 4].try_into().unwrap());
				},
				FieldType::PACKETDELTACOUNT => {
					set.packets = u32::from_be_bytes(buf[offset..offset + 4].try_into().unwrap());
				},
				FieldType::PROTOCOLIDENTIFIER => {
					set.protocol = buf[offset];
				},
				FieldType::SOURCETRANSPORTPORT => {
					set.src_port = u16::from_be_bytes(buf[offset..offset + 2].try_into().unwrap());
				},
				FieldType::DESTINATIONTRANSPORTPORT => {
					set.dst_port = u16::from_be_bytes(buf[offset..offset + 2].try_into().unwrap());
				},
				FieldType::INGRESSINTERFACE => {
					set.input_int = u16::from_be_bytes(buf[offset..offset + 2].try_into().unwrap());
				},
				FieldType::EGRESSINTERFACE => {
					set.output_int = u16::from_be_bytes(buf[offset..offset + 2].try_into().unwrap());
				},
				FieldType::FLOWSTARTMILLISECONDS => {
					set.start_time = u64::from_be_bytes(buf[offset..offset + 8].try_into().unwrap());
				},
				FieldType::FLOWENDMILLISECONDS => {
					set.end_time = u64::from_be_bytes(buf[offset..offset + 8].try_into().unwrap());
				},
				FieldType::FLOWENDREASON => {
					set.end_reason = buf[offset];
				},
				FieldType::IPCLASSOFSERVICE => {
					set.tos = buf[offset];
				},
				_ => {
					debug!("Skipping field {:?} with size {}", field.id, field.length);
				}
			}
		
			offset += field.length as usize;
		}
 
		set
    }
}

impl NetflowMsg for DataSet {
    fn print(&self) -> String {
        format!("src_addr: {}, dst_addr: {}, octets: {}, packets: {}, protocol: {}, duration: {}ms", Ipv4Addr::from(self.src_addr), Ipv4Addr::from(self.dst_addr), self.octets, self.packets, self.protocol, self.end_time - self.start_time)
    }
}

/// IPFIX FIELD TYPE ///

// http://www.iana.org/assignments/ipfix/ipfix.xml

#[derive(Serialize_repr, Deserialize_repr, PartialEq, Debug)]
#[repr(u16)]
pub enum FieldType {
	RESERVED = 0,
	OCTETDELTACOUNT = 1,
	PACKETDELTACOUNT = 2,
	DELTAFLOWCOUNT = 3,
	PROTOCOLIDENTIFIER = 4,
	IPCLASSOFSERVICE = 5,
	TCPCONTROLBITS = 6,
	SOURCETRANSPORTPORT = 7,
	SOURCEIPV4ADDRESS = 8,
	SOURCEIPV4PREFIXLENGTH = 9,
	INGRESSINTERFACE = 10,
	DESTINATIONTRANSPORTPORT = 11,
	DESTINATIONIPV4ADDRESS = 12,
	DESTINATIONIPV4PREFIXLENGTH = 13,
	EGRESSINTERFACE = 14,
	IPNEXTHOPIPV4ADDRESS = 15,
	BGPSOURCEASNUMBER = 16,
	BGPDESTINATIONASNUMBER = 17,
	BGPNEXTHOPIPV4ADDRESS = 18,
	POSTMCASTPACKETDELTACOUNT = 19,
	POSTMCASTOCTETDELTACOUNT = 20,
	FLOWENDSYSUPTIME = 21,
	FLOWSTARTSYSUPTIME = 22,
	POSTOCTETDELTACOUNT = 23,
	POSTPACKETDELTACOUNT = 24,
	MINIMUMIPTOTALLENGTH = 25,
	MAXIMUMIPTOTALLENGTH = 26,
	SOURCEIPV6ADDRESS = 27,
	DESTINATIONIPV6ADDRESS = 28,
	SOURCEIPV6PREFIXLENGTH = 29,
	DESTINATIONIPV6PREFIXLENGTH = 30,
	FLOWLABELIPV6 = 31,
	ICMPTYPECODEIPV4 = 32,
	IGMPTYPE = 33,
	SAMPLINGINTERVAL = 34,
	SAMPLINGALGORITHM = 35,
	FLOWACTIVETIMEOUT = 36,
	FLOWIDLETIMEOUT = 37,
	ENGINETYPE = 38,
	ENGINEID = 39,
	EXPORTEDOCTETTOTALCOUNT = 40,
	EXPORTEDMESSAGETOTALCOUNT = 41,
	EXPORTEDFLOWRECORDTOTALCOUNT = 42,
	IPV4ROUTERSC = 43,
	SOURCEIPV4PREFIX = 44,
	DESTINATIONIPV4PREFIX = 45,
	MPLSTOPLABELTYPE = 46,
	MPLSTOPLABELIPV4ADDRESS = 47,
	SAMPLERID = 48,
	SAMPLERMODE = 49,
	SAMPLERRANDOMINTERVAL = 50,
	CLASSID = 51,
	MINIMUMTTL = 52,
	MAXIMUMTTL = 53,
	FRAGMENTIDENTIFICATION = 54,
	POSTIPCLASSOFSERVICE = 55,
	SOURCEMACADDRESS = 56,
	POSTDESTINATIONMACADDRESS = 57,
	VLANID = 58,
	POSTVLANID = 59,
	IPVERSION = 60,
	FLOWDIRECTION = 61,
	IPNEXTHOPIPV6ADDRESS = 62,
	BGPNEXTHOPIPV6ADDRESS = 63,
	IPV6EXTENSIONHEADERS = 64,
	MPLSTOPLABELSTACKSECTION = 70,
	MPLSLABELSTACKSECTION2 = 71,
	MPLSLABELSTACKSECTION3 = 72,
	MPLSLABELSTACKSECTION4 = 73,
	MPLSLABELSTACKSECTION5 = 74,
	MPLSLABELSTACKSECTION6 = 75,
	MPLSLABELSTACKSECTION7 = 76,
	MPLSLABELSTACKSECTION8 = 77,
	MPLSLABELSTACKSECTION9 = 78,
	MPLSLABELSTACKSECTION10 = 79,
	DESTINATIONMACADDRESS = 80,
	POSTSOURCEMACADDRESS = 81,
	INTERFACENAME = 82,
	INTERFACEDESCRIPTION = 83,
	SAMPLERNAME = 84,
	OCTETTOTALCOUNT = 85,
	PACKETTOTALCOUNT = 86,
	FLAGSANDSAMPLERID = 87,
	FRAGMENTOFFSET = 88,
	FORWARDINGSTATUS = 89,
	MPLSVPNROUTEDISTINGUISHER = 90,
	MPLSTOPLABELPREFIXLENGTH = 91,
	SRCTRAFFICINDEX = 92,
	DSTTRAFFICINDEX = 93,
	APPLICATIONDESCRIPTION = 94,
	APPLICATIONID = 95,
	APPLICATIONNAME = 96,
	POSTIPDIFFSERVCODEPOINT = 98,
	MULTICASTREPLICATIONFACTOR = 99,
	CLASSNAME = 100,
	CLASSIFICATIONENGINEID = 101,
	LAYER2PACKETSECTIONOFFSET = 102,
	LAYER2PACKETSECTIONSIZE = 103,
	LAYER2PACKETSECTIONDATA = 104,
	BGPNEXTADJACENTASNUMBER = 128,
	BGPPREVADJACENTASNUMBER = 129,
	EXPORTERIPV4ADDRESS = 130,
	EXPORTERIPV6ADDRESS = 131,
	DROPPEDOCTETDELTACOUNT = 132,
	DROPPEDPACKETDELTACOUNT = 133,
	DROPPEDOCTETTOTALCOUNT = 134,
	DROPPEDPACKETTOTALCOUNT = 135,
	FLOWENDREASON = 136,
	COMMONPROPERTIESID = 137,
	OBSERVATIONPOINTID = 138,
	ICMPTYPECODEIPV6 = 139,
	MPLSTOPLABELIPV6ADDRESS = 140,
	LINECARDID = 141,
	PORTID = 142,
	METERINGPROCESSID = 143,
	EXPORTINGPROCESSID = 144,
	TEMPLATEID = 145,
	WLANCHANNELID = 146,
	WLANSSID = 147,
	FLOWID = 148,
	OBSERVATIONDOMAINID = 149,
	FLOWSTARTSECONDS = 150,
	FLOWENDSECONDS = 151,
	FLOWSTARTMILLISECONDS = 152,
	FLOWENDMILLISECONDS = 153,
	FLOWSTARTMICROSECONDS = 154,
	FLOWENDMICROSECONDS = 155,
	FLOWSTARTNANOSECONDS = 156,
	FLOWENDNANOSECONDS = 157,
	FLOWSTARTDELTAMICROSECONDS = 158,
	FLOWENDDELTAMICROSECONDS = 159,
	SYSTEMINITTIMEMILLISECONDS = 160,
	FLOWDURATIONMILLISECONDS = 161,
	FLOWDURATIONMICROSECONDS = 162,
	OBSERVEDFLOWTOTALCOUNT = 163,
	IGNOREDPACKETTOTALCOUNT = 164,
	IGNOREDOCTETTOTALCOUNT = 165,
	NOTSENTFLOWTOTALCOUNT = 166,
	NOTSENTPACKETTOTALCOUNT = 167,
	NOTSENTOCTETTOTALCOUNT = 168,
	DESTINATIONIPV6PREFIX = 169,
	SOURCEIPV6PREFIX = 170,
	POSTOCTETTOTALCOUNT = 171,
	POSTPACKETTOTALCOUNT = 172,
	FLOWKEYINDICATOR = 173,
	POSTMCASTPACKETTOTALCOUNT = 174,
	POSTMCASTOCTETTOTALCOUNT = 175,
	ICMPTYPEIPV4 = 176,
	ICMPCODEIPV4 = 177,
	ICMPTYPEIPV6 = 178,
	ICMPCODEIPV6 = 179,
	UDPSOURCEPORT = 180,
	UDPDESTINATIONPORT = 181,
	TCPSOURCEPORT = 182,
	TCPDESTINATIONPORT = 183,
	TCPSEQUENCENUMBER = 184,
	TCPACKNOWLEDGEMENTNUMBER = 185,
	TCPWINDOWSIZE = 186,
	TCPURGENTPOINTER = 187,
	TCPHEADERLENGTH = 188,
	IPHEADERLENGTH = 189,
	TOTALLENGTHIPV4 = 190,
	PAYLOADLENGTHIPV6 = 191,
	IPTTL = 192,
	NEXTHEADERIPV6 = 193,
	MPLSPAYLOADLENGTH = 194,
	IPDIFFSERVCODEPOINT = 195,
	IPPRECEDENCE = 196,
	FRAGMENTFLAGS = 197,
	OCTETDELTASUMOFSQUARES = 198,
	OCTETTOTALSUMOFSQUARES = 199,
	MPLSTOPLABELTTL = 200,
	MPLSLABELSTACKLENGTH = 201,
	MPLSLABELSTACKDEPTH = 202,
	MPLSTOPLABELEXP = 203,
	IPPAYLOADLENGTH = 204,
	UDPMESSAGELENGTH = 205,
	ISMULTICAST = 206,
	IPV4IHL = 207,
	IPV4OPTIONS = 208,
	TCPOPTIONS = 209,
	PADDINGOCTETS = 210,
	COLLECTORIPV4ADDRESS = 211,
	COLLECTORIPV6ADDRESS = 212,
	EXPORTINTERFACE = 213,
	EXPORTPROTOCOLVERSION = 214,
	EXPORTTRANSPORTPROTOCOL = 215,
	COLLECTORTRANSPORTPORT = 216,
	EXPORTERTRANSPORTPORT = 217,
	TCPSYNTOTALCOUNT = 218,
	TCPFINTOTALCOUNT = 219,
	TCPRSTTOTALCOUNT = 220,
	TCPPSHTOTALCOUNT = 221,
	TCPACKTOTALCOUNT = 222,
	TCPURGTOTALCOUNT = 223,
	IPTOTALLENGTH = 224,
	POSTNATSOURCEIPV4ADDRESS = 225,
	POSTNATDESTINATIONIPV4ADDRESS = 226,
	POSTNAPTSOURCETRANSPORTPORT = 227,
	POSTNAPTDESTINATIONTRANSPORTPORT = 228,
	NATORIGINATINGADDRESSREALM = 229,
	NATEVENT = 230,
	INITIATOROCTETS = 231,
	RESPONDEROCTETS = 232,
	FIREWALLEVENT = 233,
	INGRESSVRFID = 234,
	EGRESSVRFID = 235,
	VRFNAME = 236,
	POSTMPLSTOPLABELEXP = 237,
	TCPWINDOWSCALE = 238,
	BIFLOWDIRECTION = 239,
	ETHERNETHEADERLENGTH = 240,
	ETHERNETPAYLOADLENGTH = 241,
	ETHERNETTOTALLENGTH = 242,
	DOT1QVLANID = 243,
	DOT1QPRIORITY = 244,
	DOT1QCUSTOMERVLANID = 245,
	DOT1QCUSTOMERPRIORITY = 246,
	METROEVCID = 247,
	METROEVCTYPE = 248,
	PSEUDOWIREID = 249,
	PSEUDOWIRETYPE = 250,
	PSEUDOWIRECONTROLWORD = 251,
	INGRESSPHYSICALINTERFACE = 252,
	EGRESSPHYSICALINTERFACE = 253,
	POSTDOT1QVLANID = 254,
	POSTDOT1QCUSTOMERVLANID = 255,
	ETHERNETTYPE = 256,
	POSTIPPRECEDENCE = 257,
	COLLECTIONTIMEMILLISECONDS = 258,
	EXPORTSCTPSTREAMID = 259,
	MAXEXPORTSECONDS = 260,
	MAXFLOWENDSECONDS = 261,
	MESSAGEMD5CHECKSUM = 262,
	MESSAGESCOPE = 263,
	MINEXPORTSECONDS = 264,
	MINFLOWSTARTSECONDS = 265,
	OPAQUEOCTETS = 266,
	SESSIONSCOPE = 267,
	MAXFLOWENDMICROSECONDS = 268,
	MAXFLOWENDMILLISECONDS = 269,
	MAXFLOWENDNANOSECONDS = 270,
	MINFLOWSTARTMICROSECONDS = 271,
	MINFLOWSTARTMILLISECONDS = 272,
	MINFLOWSTARTNANOSECONDS = 273,
	COLLECTORCERTIFICATE = 274,
	EXPORTERCERTIFICATE = 275,
	DATARECORDSRELIABILITY = 276,
	OBSERVATIONPOINTTYPE = 277,
	NEWCONNECTIONDELTACOUNT = 278,
	CONNECTIONSUMDURATIONSECONDS = 279,
	CONNECTIONTRANSACTIONID = 280,
	POSTNATSOURCEIPV6ADDRESS = 281,
	POSTNATDESTINATIONIPV6ADDRESS = 282,
	NATPOOLID = 283,
	NATPOOLNAME = 284,
	ANONYMIZATIONFLAGS = 285,
	ANONYMIZATIONTECHNIQUE = 286,
	INFORMATIONELEMENTINDEX = 287,
	P2PTECHNOLOGY = 288,
	TUNNELTECHNOLOGY = 289,
	ENCRYPTEDTECHNOLOGY = 290,
	BASICLIST = 291,
	SUBTEMPLATELIST = 292,
	SUBTEMPLATEMULTILIST = 293,
	BGPVALIDITYSTATE = 294,
	IPSECSPI = 295,
	GREKEY = 296,
	NATTYPE = 297,
	INITIATORPACKETS = 298,
	RESPONDERPACKETS = 299,
	OBSERVATIONDOMAINNAME = 300,
	SELECTIONSEQUENCEID = 301,
	SELECTORID = 302,
	INFORMATIONELEMENTID = 303,
	SELECTORALGORITHM = 304,
	SAMPLINGPACKETINTERVAL = 305,
	SAMPLINGPACKETSPACE = 306,
	SAMPLINGTIMEINTERVAL = 307,
	SAMPLINGTIMESPACE = 308,
	SAMPLINGSIZE = 309,
	SAMPLINGPOPULATION = 310,
	SAMPLINGPROBABILITY = 311,
	DATALINKFRAMESIZE = 312,
	IPHEADERPACKETSECTION = 313,
	IPPAYLOADPACKETSECTION = 314,
	DATALINKFRAMESECTION = 315,
	MPLSLABELSTACKSECTION = 316,
	MPLSPAYLOADPACKETSECTION = 317,
	SELECTORIDTOTALPKTSOBSERVED = 318,
	SELECTORIDTOTALPKTSSELECTED = 319,
	ABSOLUTEERROR = 320,
	RELATIVEERROR = 321,
	OBSERVATIONTIMESECONDS = 322,
	OBSERVATIONTIMEMILLISECONDS = 323,
	OBSERVATIONTIMEMICROSECONDS = 324,
	OBSERVATIONTIMENANOSECONDS = 325,
	DIGESTHASHVALUE = 326,
	HASHIPPAYLOADOFFSET = 327,
	HASHIPPAYLOADSIZE = 328,
	HASHOUTPUTRANGEMIN = 329,
	HASHOUTPUTRANGEMAX = 330,
	HASHSELECTEDRANGEMIN = 331,
	HASHSELECTEDRANGEMAX = 332,
	HASHDIGESTOUTPUT = 333,
	HASHINITIALISERVALUE = 334,
	SELECTORNAME = 335,
	UPPERCILIMIT = 336,
	LOWERCILIMIT = 337,
	CONFIDENCELEVEL = 338,
	INFORMATIONELEMENTDATATYPE = 339,
	INFORMATIONELEMENTDESCRIPTION = 340,
	INFORMATIONELEMENTNAME = 341,
	INFORMATIONELEMENTRANGEBEGIN = 342,
	INFORMATIONELEMENTRANGEEND = 343,
	INFORMATIONELEMENTSEMANTICS = 344,
	INFORMATIONELEMENTUNITS = 345,
	PRIVATEENTERPRISENUMBER = 346,
	VIRTUALSTATIONINTERFACEID = 347,
	VIRTUALSTATIONINTERFACENAME = 348,
	VIRTUALSTATIONUUID = 349,
	VIRTUALSTATIONNAME = 350,
	LAYER2SEGMENTID = 351,
	LAYER2OCTETDELTACOUNT = 352,
	LAYER2OCTETTOTALCOUNT = 353,
	INGRESSUNICASTPACKETTOTALCOUNT = 354,
	INGRESSMULTICASTPACKETTOTALCOUNT = 355,
	INGRESSBROADCASTPACKETTOTALCOUNT = 356,
	EGRESSUNICASTPACKETTOTALCOUNT = 357,
	EGRESSBROADCASTPACKETTOTALCOUNT = 358,
	MONITORINGINTERVALSTARTMILLISECONDS = 359,
	MONITORINGINTERVALENDMILLISECONDS = 360,
	PORTRANGESTART = 361,
	PORTRANGEEND = 362,
	PORTRANGESTEPSIZE = 363,
	PORTRANGENUMPORTS = 364,
	STAMACADDRESS = 365,
	STAIPV4ADDRESS = 366,
	WTPMACADDRESS = 367,
	INGRESSINTERFACETYPE = 368,
	EGRESSINTERFACETYPE = 369,
	RTPSEQUENCENUMBER = 370,
	USERNAME = 371,
	APPLICATIONCATEGORYNAME = 372,
	APPLICATIONSUBCATEGORYNAME = 373,
	APPLICATIONGROUPNAME = 374,
	ORIGINALFLOWSPRESENT = 375,
	ORIGINALFLOWSINITIATED = 376,
	ORIGINALFLOWSCOMPLETED = 377,
	DISTINCTCOUNTOFSOURCEIPADDRESS = 378,
	DISTINCTCOUNTOFDESTINATIONIPADDRESS = 379,
	DISTINCTCOUNTOFSOURCEIPV4ADDRESS = 380,
	DISTINCTCOUNTOFDESTINATIONIPV4ADDRESS = 381,
	DISTINCTCOUNTOFSOURCEIPV6ADDRESS = 382,
	DISTINCTCOUNTOFDESTINATIONIPV6ADDRESS = 383,
	VALUEDISTRIBUTIONMETHOD = 384,
	RFC3550JITTERMILLISECONDS = 385,
	RFC3550JITTERMICROSECONDS = 386,
	RFC3550JITTERNANOSECONDS = 387,
	DOT1QDEI = 388,
	DOT1QCUSTOMERDEI = 389,
	FLOWSELECTORALGORITHM = 390,
	FLOWSELECTEDOCTETDELTACOUNT = 391,
	FLOWSELECTEDPACKETDELTACOUNT = 392,
	FLOWSELECTEDFLOWDELTACOUNT = 393,
	SELECTORIDTOTALFLOWSOBSERVED = 394,
	SELECTORIDTOTALFLOWSSELECTED = 395,
	SAMPLINGFLOWINTERVAL = 396,
	SAMPLINGFLOWSPACING = 397,
	FLOWSAMPLINGTIMEINTERVAL = 398,
	FLOWSAMPLINGTIMESPACING = 399,
	HASHFLOWDOMAIN = 400,
	TRANSPORTOCTETDELTACOUNT = 401,
	TRANSPORTPACKETDELTACOUNT = 402,
	ORIGINALEXPORTERIPV4ADDRESS = 403,
	ORIGINALEXPORTERIPV6ADDRESS = 404,
	ORIGINALOBSERVATIONDOMAINID = 405,
	INTERMEDIATEPROCESSID = 406,
	IGNOREDDATARECORDTOTALCOUNT = 407,
	DATALINKFRAMETYPE = 408,
	SECTIONOFFSET = 409,
	SECTIONEXPORTEDOCTETS = 410,
	DOT1QSERVICEINSTANCETAG = 411,
	DOT1QSERVICEINSTANCEID = 412,
	DOT1QSERVICEINSTANCEPRIORITY = 413,
	DOT1QCUSTOMERSOURCEMACADDRESS = 414,
	DOT1QCUSTOMERDESTINATIONMACADDRESS = 415,
	POSTLAYER2OCTETDELTACOUNT = 417,
	POSTMCASTLAYER2OCTETDELTACOUNT = 418,
	POSTLAYER2OCTETTOTALCOUNT = 420,
	POSTMCASTLAYER2OCTETTOTALCOUNT = 421,
	MINIMUMLAYER2TOTALLENGTH = 422,
	MAXIMUMLAYER2TOTALLENGTH = 423,
	DROPPEDLAYER2OCTETDELTACOUNT = 424,
	DROPPEDLAYER2OCTETTOTALCOUNT = 425,
	IGNOREDLAYER2OCTETTOTALCOUNT = 426,
	NOTSENTLAYER2OCTETTOTALCOUNT = 427,
	LAYER2OCTETDELTASUMOFSQUARES = 428,
	LAYER2OCTETTOTALSUMOFSQUARES = 429,
	LAYER2FRAMEDELTACOUNT = 430,
	LAYER2FRAMETOTALCOUNT = 431,
	PSEUDOWIREDESTINATIONIPV4ADDRESS = 432,
	IGNOREDLAYER2FRAMETOTALCOUNT = 433
}